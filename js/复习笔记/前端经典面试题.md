# 前端经典面试题

## js数据类型

共七种基本数据类型和一种引用数据类型
基本数据类型有：number、string、boolean、undefined、null、symbol（ES6新增）
引用数据类型：object

1. number:
* 整数和小数：1、 1.1、 .1
* 科学记数法：1.23e2
* 二进制：0b11
* 八进制：011（后来 ES5 添加了 0o11 语法）
* 十六进制：0x11

2. String

## 判断变量的类型

## 数据类型转换

## 原型和原型链

## 闭包及优缺点

## call/apply/bind

## DOM事件流和事件委托

## Cookie/storage

## 数组和对象的常见方法

## new内部做了什么

## 防抖/节流

## requestAnimationFrame

## this指向

## 作用域链

## let/const/var的区别

## ES6异步编程：Promise和async await

## 箭头函数

## javaScript的运行机制

## 实现继承的几种方式

## 垃圾回收

#### 为什么进行垃圾回收？
 有些数据使用后，就不再需要，这种数据就被称为**垃圾数据**，如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。
不同的语言有不同的垃圾回收策略，分为**手动回收**和**自动回收**两种策略，例如C语言就是手动回收，需要手动用代码释放，不然会发生内存泄漏，另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。
在js中，原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的。

#### 调用栈中的数据是如何回收的？

例如在调用栈执行某个函数时，会有一个记录当前执行状态的指针（称为 **ESP**），当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

#### 堆中的数据是如何回收的？

不过，保存在堆中的对象依然占用的空间，要回收堆中的垃圾数据，就需要用到 JavaScript 中的**垃圾回收器**了。

#### 代际假说：

 V8 中会把堆分为**新生代**和**老生代**两个区域，

 新生代中存放的是**生存时间短、小的对象**，使用**副垃圾回收器**，

 老生代中存放的**生存时间久、大的对象**。使用**主垃圾回收器**。

#### 副垃圾回收器
使用**Scavenge 算法**：把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，
完成标记后会把存活的对象复制到空闲空间，完成复制后两个区域会进行翻转。

并且采用了**对象晋升策略**经过两次垃圾回收依然还存活的对象，会被移动到老生区中。
#### 主垃圾回收器
标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。清除之后会产生碎片空间，碎片过多会导致大对象无法分配足够多的内存，所以会让存活对象向一端移动，

#### 全停顿问题会造成页面卡顿

js是单线程的，一旦执行垃圾回收算法，其他正在执行的js脚本就会暂停，为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。
