# new 实现原理 1.js

# 输出了什么？ 2.js
函数一定有prototype，该属性一定会指向函数的原型对象，默认情况下，所有的原型对象都自动获得一个constructor属性，这个属性指向了prototype所在的函数。

p2 的Person.prototype的值已经变成了{....}, 他是没有constructor属性的，所以Person会让你向上委托，找到Object

# 修改了prototype后，仍想让p2.constructor

添加一个constructor属性

# 介绍一下原型链继承   3.js

缺点：

1. 现有的实例会继承多余的属性，且这些属性是共享的
2. 子类型实例无法向超类型函数传递参数

# 解决原型链继承的缺点  4.js

借用构造函数继承

* 在子类的构造函数中调用超类的构造函数

缺点：

1. 超类中的方法无法复用，
2. 无法继承超类原型上的属性

# 组合继承  5.js

# 寄生组合继承 5.js注释部分
